#include <Arduino.h>


#include <almllib.h>
// #include "myClass.h"


 

// #define RES (deffunction-1)


al_taskScheduler   * _TaskScheduler;



void _Program_cb(const String itemBaseName, const uint16_t& itemBasePos, uint8_t id, boolean updWebserver);
 





void drawPixelXY(uint8_t strip, uint16_t x, int16_t y, const CRGB &color)  {
  uint16_t  width, height;
  uint8_t   segements;
  CRGB      * arrayLeds = leds_managePtrGet()->get_crgbArray(strip);
  leds_managePtrGet()->get_matrix(strip)->get_width(width);
  leds_managePtrGet()->get_matrix(strip)->get_height(height);
  leds_managePtrGet()->get_matrix(strip)->get_segements(segements);
  if ((width <= 0) && (height <= 0)) return;
  if (x < 0 || x > (int16_t)(width - 1) || y < 0 || y > (int16_t)(height - 1)) return;
  uint32_t thisPixel = leds_managePtrGet()->getPixelNumber(strip, (uint16_t)x, (uint16_t)y) * segements;
  for (uint16_t i = 0; i < segements; i++) {
    arrayLeds[thisPixel + i] = color;
  }
}

void _testM(uint8_t _delay){
  uint8_t strip = 0;
  uint16_t width;
  uint16_t height;
  leds_managePtrGet()->get_matrix(strip)->get_width(width);
  leds_managePtrGet()->get_matrix(strip)->get_height(height);  
    uint8_t h = 0;
    // for (uint8_t y = 0; y < _height; y++) {
        for (uint8_t x = 0; x < width-1; x++) {
            CRGB c = CHSV(h, 255, 255);
            drawPixelXY(strip, x, 0, c);
            delay(_delay);
            leds_managePtrGet()->showLeds(strip,60);
        }
        for (uint8_t x = 1; x < width; x++) {
            CRGB c = CHSV(h, 255, 255);
            uint16_t i = x;
            i = (width-1) - i;            
            drawPixelXY(strip, i, height-1, c);
            delay(_delay);
            leds_managePtrGet()->showLeds(strip,60);
        } 
        h+= 60;
        for (uint8_t x = 0; x < width-1; x++) {
            CRGB c = CHSV(h, 255, 255);
            drawPixelXY(strip, x, (height-1)/2, c);
            delay(_delay);
            leds_managePtrGet()->showLeds(strip,60);
        }  
        CRGB cm =  CHSV(h, 255, 255);          
        h+= 60;
        for (uint8_t x = 0; x < height; x++) {
            CRGB c = CHSV(h, 255, 255);
            drawPixelXY(strip, width-1, x, c);
            delay(_delay);
            leds_managePtrGet()->showLeds(strip,60);
        } 
        h+= 60;   
        for (uint8_t x = 1; x < height-1; x++) {
            if (x == (height-1)/2) drawPixelXY(strip, (width-1)/2, x, 0);
            else drawPixelXY(strip, (width-1)/2, x, cm);
            delay(_delay);
            leds_managePtrGet()->showLeds(strip,60);
        }  
        uint8_t top, topend, start, startend;
        uint8_t face_x = width/4;
        uint8_t face_y = width/2;
        for (uint8_t k = 0; k < 2; k++) {
          for (uint8_t j = 0; j < 2; j++) {
            start = (j==0) ? j : (j * face_x);
            h+= 100;
            switch (j) {
              case 1: 
              case 3: startend = face_x*(j+1) -1; break;
              default : startend = face_x*(j+1); break;
            } 
            for (uint8_t x = start; x < startend; x++) {
              top     = (k==0) ? k+1 : (k * face_y)-1;
              topend  = (k==0) ? (k+1)*(face_y-2) : ((k+1)*(face_y-2))+1;
              for (uint8_t y = top; y < topend; y++) {
                CRGB c = CHSV(h, 255, 255);
                drawPixelXY(strip, x, y, c);
                delay(_delay);
                leds_managePtrGet()->showLeds(strip,60);
              }               
            }               
          }               
        }               
}



void keyboard_getter(const String & v1) {
  int rSize = 0;
  // DynamicJsonDocument doc(3500);

  LList<SplitItem *> _SplitItem;
  splitText(v1, "&",  ':', &_SplitItem);

  for(int j = 0; j < _SplitItem.size(); ++j) {
    const char** split = al_tools::explode(_SplitItem[j]->_value, ',', rSize);
    if (split) {
      for(int i = 0; i < rSize; ++i) {
        Serial.printf("[%d] %s\n", i , split[i]);
        if (strcmp_P(_SplitItem[j]->_cmd, "scale") == 0)  {LAMPPTRGET()->effect_setscale(0, atoi(split[i]));}                           
        if (strcmp_P(_SplitItem[j]->_cmd, "bri") == 0)    {LAMPPTRGET()->effect_setbri(0,   atoi(split[i]));}                           
        if (strcmp_P(_SplitItem[j]->_cmd, "speed") == 0)  {LAMPPTRGET()->effect_setspd(0,   atoi(split[i]));}                           
        if (strcmp_P(_SplitItem[j]->_cmd, "c3") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();
          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 3) {
              controls[i]->setVal(al_tools::ch_toString(split[i]));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrlNoSet(controls[i]);   
              Serial.println("setval");           
            }
          }
        }   
        if (strcmp_P(_SplitItem[j]->_cmd, "c4") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();
          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 4) {
              controls[i]->setVal(al_tools::ch_toString(split[i]));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrlNoSet(controls[i]);  
              Serial.println("setval");             
            }
          }
        }   
        if (strcmp_P(_SplitItem[j]->_cmd, "c5") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();
          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 5) {
              controls[i]->setVal(al_tools::ch_toString(split[i]));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrlNoSet(controls[i]);              
            }
          }
        }   
        if (strcmp_P(_SplitItem[j]->_cmd, "c6") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();
          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 6) {
              controls[i]->setVal(al_tools::ch_toString(split[i]));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrlNoSet(controls[i]);              
            }
          }
        }   

        // if (strcmp_P(_SplitItem[j]->_cmd, "fade") == 0)  {LAMPPTRGET()->effect_setfade(0,   atoi(split[i]));}                           
      }
      for(int i = 0; i < rSize; ++i) {
        delete split[i];
      }
      delete[] split; 
    } else {
        // if (strcmp_P(_SplitItem[j]->_cmd, "WC") == 0)     api_getter(doc, _SplitItem[j]->_value);                           
        // #ifdef ALSI_ENABLED
        // if (strcmp_P(_SplitItem[j]->_cmd, "ALSI") == 0)   ALSYSINFO_getterByCat(doc, _SplitItem[j]->_value);                           
        // if (strcmp_P(_SplitItem[j]->_cmd, "ALSII") == 0)  ALSYSINFO_getterByKey(doc, _SplitItem[j]->_value);   
        // #endif    
        if (strcmp_P(_SplitItem[j]->_cmd, "scale") == 0)  {LAMPPTRGET()->effect_setscale(0, atoi(_SplitItem[j]->_value));} // 2                        
        if (strcmp_P(_SplitItem[j]->_cmd, "bri") == 0)    {LAMPPTRGET()->effect_setbri(0,   atoi(_SplitItem[j]->_value));} // 0                          
        if (strcmp_P(_SplitItem[j]->_cmd, "speed") == 0)  {LAMPPTRGET()->effect_setspd(0,   atoi(_SplitItem[j]->_value));} // 1    
        if (strcmp_P(_SplitItem[j]->_cmd, "c3") == 0)  { // 3 fade
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();
          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 3) {
              controls[i]->setVal(al_tools::ch_toString(_SplitItem[j]->_value));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrl(controls[i]);              
            }
          }
        }    
        if (strcmp_P(_SplitItem[j]->_cmd, "c4") == 0)  { // 4 huetimer 1

          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();
          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 4) {
              controls[i]->setVal(al_tools::ch_toString(_SplitItem[j]->_value));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrl(controls[i]);              
            }
          }
        }    
        if (strcmp_P(_SplitItem[j]->_cmd, "c5") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();
          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 5) {
              controls[i]->setVal(al_tools::ch_toString(_SplitItem[j]->_value));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrl(controls[i]);              
            }
          }
        }    
        if (strcmp_P(_SplitItem[j]->_cmd, "c6") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();

          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 6) {
              controls[i]->setVal(al_tools::ch_toString(_SplitItem[j]->_value));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrl(controls[i]);              
            }
          }
        } 
        if (strcmp_P(_SplitItem[j]->_cmd, "c7") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();

          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 7) {
              controls[i]->setVal(al_tools::ch_toString(_SplitItem[j]->_value));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrl(controls[i]);              
            }
          }
        } 
        if (strcmp_P(_SplitItem[j]->_cmd, "c8") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();

          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 8) {
              controls[i]->setVal(al_tools::ch_toString(_SplitItem[j]->_value));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrl(controls[i]);              
            }
          }
        } 
        if (strcmp_P(_SplitItem[j]->_cmd, "c9") == 0)  {
          LList<UIControl*>&controls = LAMPPTRGET()->get_effect(0)->getControls();

          for(int i = 0; i < controls.size(); ++i) {
            if (controls[i]->getId() == 9) {
              controls[i]->setVal(al_tools::ch_toString(_SplitItem[j]->_value));
              LAMPPTRGET()->get_effect(0)->worker->setDynCtrl(controls[i]);              
            }
          }
        } 
    }
  }
  while (_SplitItem.size()) {
    SplitItem *eff = _SplitItem.shift();
    delete eff;
  }
  _SplitItem.clear();

}
void setup() {
  Serial.begin(115200);
  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime > 5000); ) { }
  delay(1000);
  Serial.println();
  Serial.println("STARTUP");

  #ifdef FILESYSTEM
    #if defined(ESP8266)
      FILESYSTEM.begin();
      FILESYSTEM.format();
    #elif defined(ESP32)
      FILESYSTEM.begin(true);
    #endif
  #endif
  
  #ifdef ALT_DEBUG_TARCE
    ALT_debugBuffer = new char[1024];  
    _DebugPrintList.add("main");  
    _DebugPrintList.add("alml_task");  
  #endif 

  WCEVO_managerPtrGet()->set_cm(WCEVO_CM_AP);
  WCEVO_managerPtrGet()->set_cmFail(WCEVO_CF_AP);
  #ifdef FILESYSTEM
    WCEVO_managerPtrGet()->credentials_from_fs();  
  #endif
  WCEVO_managerPtrGet()->start();
  WCEVO_managerPtrGet()->print();

  #ifdef DEBUG_KEYBOARD
    _Sr_menu.add("api setterr", "|", [](const String & v1, const String & v2) {  
     Serial.printf("CMD: %s - VAL: %s\n", v1.c_str(), v2.c_str());
     keyboard_getter(v1);    
    }, SR_MM::SRMM_KEYVAL);   
  #endif 

  #ifdef ESP8266
    WiFi.setPhyMode(WIFI_PHY_MODE_11N);
  #endif  
  WiFi.disconnect(false);
  WiFi.mode(WIFI_STA);

  // _leds_manage = new leds_manage(); 
  // #if defined (ADS_PIN_1) || defined (ADS_PINW_1)
  //   _leds_manage->strip_add(&myLed_1);
  // #endif
  // 
  uint8_t cnt= 0;

  for(int i = 0; i < _effeNamIDList_cnt; ++i) {
    String item = al_tools::ch_toString(_effeNamIDList[i]._nameId);

    if(item.indexOf("Syncro") > -1)  continue;
    if(item.indexOf("Rainbow") < 0)  continue;

    cnt++;
  }

  Serial.printf("size: %d\n", cnt);




  new Device(ADS_NAME, ADS_OC);
  al_tools::SPIFFS_PRINT(false); 
  // _TaskScheduler = new al_taskScheduler(9);
  // _TaskScheduler->get_task(0)->set_callbackOstart([=](){
  // String heap, timer;
  // al_tools::on_time_h(timer);
  // Serial.println(timer);
  // });
  // _TaskScheduler->get_task(0)->set_iteration_max(0);
  // _TaskScheduler->get_task(0)->set_taskDelay(ETD::ETD_DELAY, true, 3000, 1);
  // _TaskScheduler->get_task(0)->set_taskDelayEnabled(ETD::ETD_DELAY, true);
  // _TaskScheduler->get_task(0)->set_enabled(true); 

  String heap, timer;
  al_tools::on_time_h(timer);
  Serial.println(timer);

  // initIR();


  // changeEffectByName(TEFF_RainbowWave);



    DynamicJsonDocument doc(1024);
    JsonArray           arr;
    JsonObject          var;
    String              reply;
    doc[F("op")]    = 0;
    doc[F("type")]  = "SOSKCET";
    arr = doc.createNestedArray(F("set"));  
    var = arr.createNestedObject();
    // var[F("n")] = FPSTR(APPT_SETTER_ARRAY[p]);
    // var[F("v")] = value;
    arr = doc.createNestedArray(F("get"));  
    arr.add("loop");
    _AP_Api.parsingRequest(doc, reply, "");
    // _Webserver.socket_send(reply);
    Serial.printf("testapapi:\n%s\n", reply.c_str());
}


uint8_t phase_test;
void loop() {
  phase_test = sawtooth_wave(160);
  // handleIR();
  // _TaskScheduler->loop();
  // ts.execute();
  DevicePtrGet()->loop();
  // if ((millis() - _tTest) > 50) {
  // //   ALT_TRACEC("main", "TEST\n");
  // 
  // 

  //   EffectMath::MoveFractionalNoise(0, MOVE_X, noise3d, 8);//4
  //   EffectMath::MoveFractionalNoise(0, MOVE_Y, noise3d, 8, 0.33);//4
  //   _leds_manage->showLeds(0,60);
  //   _tTest = millis();
  // }
   // if (_Program) _Program->handle();
}

/*


  uint16_t nbLeds,nbLeds2;
  // boolean isTw;
  // CRGB * arrayLeds = leds_managePtrGet()->get_crgbArray(0);
  leds_managePtrGet()->get_numLeds(0, nbLeds);
  // leds_managePtrGet()->get_numLeds(1, nbLeds2);
  Serial.printf("nbLeds: %d\n", nbLeds);
  // leds_managePtrGet()->get_ledsIsTw(0, isTw);
  // uint8_t g = random(20,80);
  // for(int i = 0; i < nbLeds; ++i) {
  //  arrayLeds[i] = CRGB(0,60,g);
  // }
  // leds_managePtrGet()->showLeds(strip,60);

  // #ifdef WIDTH
  // #endif






  // Serial.print("_WIDTH: ");Serial.println(_WIDTH);
  // Serial.print("THIS_X: "); Serial.println(THIS_X);
  // Serial.print("THIS_Y: ");Serial.println(THIS_Y);
  // Serial.print("CONNECTION_ANGLE: ");Serial.println(CONNECTION_ANGLE);
  // Serial.print("STRIP_DIRECTION: ");Serial.println(STRIP_DIRECTION);
  // Serial.print("MATRIX_TYPE: ");Serial.println(MATRIX_TYPE);
  // _testM(80);
  // String s;
  // DevicePtrGet()->outputs_toNode(s);
  // 
  // 
  // leds_managePtrGet()->leds_segment.segment_new(0, 14);
  // leds_managePtrGet()->leds_segment.segment_new(15, 29);
  // 
  // 
// DynamicJsonDocument doc(1024);
// JsonObject obj = doc.to<JsonObject>();
// obj[F("r")] = 0;
// obj[F("g")] = 255;
// obj[F("b")] = 0;
// DevicePtrGet()->get_outputArray(0)->set_rgb(FPSTR(req_lampSetColor), obj);
// DevicePtrGet()->get_outputArray(0)->set_color();
// leds_managePtrGet()->showLeds(0,60);
  // 
delay(1000);

// uint8_t speed = 200;
// uint8_t scale = 30;
// LAMPPTRGET()->effect_setspd(0, speed);
// LAMPPTRGET()->effect_setbri(0, 200);
// LAMPPTRGET()->effect_setscale(0,120);

// int fled = nbLeds;
// int defled = fled - nbLeds2;
// defled = (defled*100)/fled;
// defled = (speed*defled)/100;
// defled = speed - defled;

// int defscale = fled - nbLeds2;
// defscale = (defscale*100)/fled;
// defscale = (scale*defscale)/100;
// defscale = scale - defscale;


LAMPPTRGET()->effect_setspd(0, 200);
LAMPPTRGET()->effect_setbri(0, 200);
LAMPPTRGET()->effect_setscale(0,60);

*/