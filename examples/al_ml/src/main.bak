#include <Arduino.h>


#include <almllib.h>
// #include "myClass.h"

Program         * _Program = nullptr;


AsyncWebServer    web_server(80);
// AsyncWebSocket    web_socket("/ws");
// AsyncEventSource  event("/events");


DNSServer       dnsServer;
WCEVO_manager   _WCEVO_manager("almlbeta01", &dnsServer, &web_server);  

// #define RES (deffunction-1)

#ifdef ADS_PIN_1
  leds <ADS_PIN_1, GRB>myLed_1(0);

#endif

leds_manage * _leds_manage = nullptr;



void drawPixelXY(uint8_t strip, uint16_t x, int16_t y, const CRGB &color)  {
  uint16_t  width, height;
  uint8_t   segements;
  CRGB      * arrayLeds = _leds_manage->get_crgbArray(strip);
  _leds_manage->get_matrix(strip)->get_width(width);
  _leds_manage->get_matrix(strip)->get_height(height);
  _leds_manage->get_matrix(strip)->get_segements(segements);
  if ((width <= 0) && (height <= 0)) return;
  if (x < 0 || x > (int16_t)(width - 1) || y < 0 || y > (int16_t)(height - 1)) return;
  uint32_t thisPixel = _leds_manage->getPixelNumber(strip, (uint16_t)x, (uint16_t)y) * segements;
  for (uint16_t i = 0; i < segements; i++) {
    arrayLeds[thisPixel + i] = color;
  }
}

void _testM(uint8_t _delay){
  uint8_t strip = 0;
  uint16_t width;
  uint16_t height;
  _leds_manage->get_matrix(strip)->get_width(width);
  _leds_manage->get_matrix(strip)->get_height(height);  
    uint8_t h = 0;
    // for (uint8_t y = 0; y < _height; y++) {
        for (uint8_t x = 0; x < width-1; x++) {
            CRGB c = CHSV(h, 255, 255);
            drawPixelXY(strip, x, 0, c);
            delay(_delay);
            _leds_manage->showLeds(strip,60);
        }
        for (uint8_t x = 1; x < width; x++) {
            CRGB c = CHSV(h, 255, 255);
            uint16_t i = x;
            i = (width-1) - i;            
            drawPixelXY(strip, i, height-1, c);
            delay(_delay);
            _leds_manage->showLeds(strip,60);
        } 
        h+= 60;
        for (uint8_t x = 0; x < width-1; x++) {
            CRGB c = CHSV(h, 255, 255);
            drawPixelXY(strip, x, (height-1)/2, c);
            delay(_delay);
            _leds_manage->showLeds(strip,60);
        }  
        CRGB cm =  CHSV(h, 255, 255);          
        h+= 60;
        for (uint8_t x = 0; x < height; x++) {
            CRGB c = CHSV(h, 255, 255);
            drawPixelXY(strip, width-1, x, c);
            delay(_delay);
            _leds_manage->showLeds(strip,60);
        } 
        h+= 60;   
        for (uint8_t x = 1; x < height-1; x++) {
            if (x == (height-1)/2) drawPixelXY(strip, (width-1)/2, x, 0);
            else drawPixelXY(strip, (width-1)/2, x, cm);
            delay(_delay);
            _leds_manage->showLeds(strip,60);
        }  
        uint8_t top, topend, start, startend;
        uint8_t face_x = width/4;
        uint8_t face_y = width/2;
        for (uint8_t k = 0; k < 2; k++) {
          for (uint8_t j = 0; j < 2; j++) {
            start = (j==0) ? j : (j * face_x);
            h+= 100;
            switch (j) {
              case 1: 
              case 3: startend = face_x*(j+1) -1; break;
              default : startend = face_x*(j+1); break;
            } 
            for (uint8_t x = start; x < startend; x++) {
              top     = (k==0) ? k+1 : (k * face_y)-1;
              topend  = (k==0) ? (k+1)*(face_y-2) : ((k+1)*(face_y-2))+1;
              for (uint8_t y = top; y < topend; y++) {
                CRGB c = CHSV(h, 255, 255);
                drawPixelXY(strip, x, y, c);
                delay(_delay);
                _leds_manage->showLeds(strip,60);
              }               
            }               
          }               
        }               
}


void setup() {
  Serial.begin(115200);
  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime > 5000); ) { }
  delay(1000);
  Serial.println();
  Serial.println("STARTUP");

  #ifdef FILESYSTEM
    #if defined(ESP8266)
      FILESYSTEM.begin();
    #elif defined(ESP32)
      FILESYSTEM.begin(false);
    #endif
    al_tools::SPIFFS_PRINT(false);  
  #endif
  
  #ifdef ALT_DEBUG_TARCE
  ALT_debugBuffer = new char[1024];  
  #endif
  #ifdef DEBUG_KEYBOARD
   _DebugPrintList.add("main");  
  #endif 

  _WCEVO_manager.set_cm(WCEVO_CM_AP);
  _WCEVO_manager.set_cmFail(WCEVO_CF_AP);
  #ifdef FILESYSTEM
  // _WCEVO_manager.credentials_from_fs();  
  #endif
  _WCEVO_manager.start();
  _WCEVO_manager.print();



  #ifdef ESP8266
    WiFi.setPhyMode(WIFI_PHY_MODE_11N);
  #endif  
  WiFi.disconnect(false);
  WiFi.mode(WIFI_STA);

  _leds_manage = new leds_manage(); 
  #if defined (ADS_PIN_1) || defined (ADS_PINW_1)
    _leds_manage->strip_add(&myLed_1);
  #endif

  uint16_t nbLeds;
  // boolean isTw;
  // CRGB * arrayLeds = _leds_manage->get_crgbArray(0);
  _leds_manage->get_numLeds(0, nbLeds);
  Serial.printf("nbLeds: %d\n", nbLeds);
  // _leds_manage->get_ledsIsTw(0, isTw);
  // uint8_t g = random(20,80);
  // for(int i = 0; i < nbLeds; ++i) {
  //  arrayLeds[i] = CRGB(0,60,g);
  // }
  // _leds_manage->showLeds(strip,60);

  // #ifdef WIDTH
  // #endif
  #ifdef HEIGHT
  uint16_t h = HEIGHT;
  Serial.print("HEIGHT: ");Serial.println(h);  
  #endif
  // Serial.print("_WIDTH: ");Serial.println(_WIDTH);
  // Serial.print("THIS_X: "); Serial.println(THIS_X);
  // Serial.print("THIS_Y: ");Serial.println(THIS_Y);
  // Serial.print("CONNECTION_ANGLE: ");Serial.println(CONNECTION_ANGLE);
  // Serial.print("STRIP_DIRECTION: ");Serial.println(STRIP_DIRECTION);
  // Serial.print("MATRIX_TYPE: ");Serial.println(MATRIX_TYPE);
  // _testM(80);

}


uint32_t _tTest;
void loop() {
  _WCEVO_manager.handleConnection();  
  #ifdef DEBUG_KEYBOARD
  _Sr_menu.serialRead();  
  #endif

  // if ((millis() - _tTest) > 50) {
  // //   ALT_TRACEC("main", "TEST\n");

  //   EffectMath::MoveFractionalNoise(0, MOVE_X, noise3d, 8);//4
  //   EffectMath::MoveFractionalNoise(0, MOVE_Y, noise3d, 8, 0.33);//4
  //   _leds_manage->showLeds(0,60);
  //   _tTest = millis();
  // }
}
